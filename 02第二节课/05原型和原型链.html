<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
1. js最顶层的原型是Object.prototype 5 <br>
2. 所有的引用类型的原型都是Object.prototype 5 <br>
2. 所有的引用类型都是Object的子类 5 <br>

<script>
    console.log(Object.prototyoe)
    console.log(Array instanceof Object, 1)
    console.log(1 instanceof Object, 2)
    console.log(null instanceof Object, 3)
    console.log(Number instanceof Object, 4)
    console.log(typeof Number, 5)
    console.log(typeof Object, 6)
    // String, Object, Array, Date, Set, Map
</script>
2. 当我们创建一个对象，引用类型数据的时候，这个对象都会有一个__proro__属性，它的值我们成为对象的原型对象。 <br>
3. 当我们用构造函数F创建一个对象的时候f，f.__proto__ === F.prototype <br>
<script>
    function F() {
    }

    console.log(F.__proto__ === Function.prototype, 11111111111)
    console.log(Function.prototype.__proto__ === Object.prototype, 222222)
    let f = new F();
    console.log(f.__proto__ === F.prototype, 123) // 构造函数返回对象除外
    console.log(f instanceof F)
    let a = []
    console.log(a instanceof Array, 123123)

    // f.__proto__ === F.prototype
    //  F.prototype.__proto__ === Object.prototype


</script>
4. 每个原型对象都会有个constructor属性，它指向该构造函数 <br>
<script>
    console.log(F.prototype.constructor === F, 456)
</script>
5. 当我们访问对象的属性和方法的时候，先去对象自身进行寻找，如果没有在顺着原型链去寻找。一直到顶层的Object.prototype ===
F.prototype <br>
<script>
    function H() {
        this.name = 'tom' // 私有属性
        this.say = function () { // 私有方法
            console.log(this.name)
        }
    }

    H.prototype.age = 12; // 共有属性
    H.prototype.sayAge = function () { // 共有方法
        console.log(this.age)
    }
    Function.prototype.male = 'girl'
    let h = new H();
    console.log(h.name)
    console.log(h.age)
    h.say()
    h.sayAge()

    console.log(h.male, 444444)
    console.log(H.male)
    // 遍历所有的属性，包括继承的。但是不不包括symbol
    for (let key in h) {
        console.log(h[key], key, 1)
    }
    // 遍历私有属性
    Object.keys(h).forEach(function (key) {
        console.log(h[key], key, 2)
    })
    Object.values(h)
</script>
</body>
</html>
